---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# CNweaveR

<!-- badges: start -->
[![R-CMD-check](https://github.com/joeymays/CNweaveR/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/joeymays/CNweaveR/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->

CNweaveR enables basic analysis of CNVs using custom genome-wide targeted DNA sequencing panels for the Mission Bio Tapestri system.

## Installation

You can install the development version of CNweaveR from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("joeymays/CNWeaveR")
```

## Basic Usage

### Data Import

In practice, the dataset is imported from the `.h5` file that is generated by the Tapestri Pipeline.
```{r example, message=FALSE}
library(CNweaveR)
```

```{r, eval=FALSE}
## NOT RUN
example.exp <- createTapestriExperiment(h5.filename)
```

We'll use a toy dataset for this example.

```{r}
example.exp <- newTapestriExperimentExample()
```

### Clustering

We cluster on allele frequency to partition different cell lines represented in the experiment.
First, run PCA and use the knee plot to identify the PCs accounting for the most variation in the dataset.

```{r clustering 1}
example.exp <- runPCA(example.exp)
PCAKneePlot(example.exp)
```

Run UMAP with the top PCs. 

```{r clustering 2}
example.exp <- runUMAP(example.exp, pca.dims = 1:2)
```

```{r clustering 3}
reducedDimPlot(example.exp, dim.reduction = "umap")
```

Run `getClusters()` to cluster with dbscan.

```{r clustering 4}
example.exp <- getClusters(example.exp, eps = 0.9)
```

Visualize UMAP, using "cluster" label to color.

```{r clustering viz}
reducedDimPlot(example.exp, dim.reduction = "umap", group.label = "cluster")
```

Rename cluster labels by renaming the factor levels of "cluster". 
The `forcats` package makes this easy.

```{r rename clusters}
colData(example.exp)$cluster <- forcats::fct_recode(colData(example.exp)$cluster, cellline1 = "1", cellline2 = "2", cellline3 = "3")
```

## Ploidy Calculation 

Normalize counts and calculate ploidy relative to cellline 3, which is diploid. `control.ploidy` gives the cluster label and ploidy value to normalize each chromosome arm to. 

```{r}
example.exp <- normalizeCounts(example.exp)
control.ploidy <- generateControlPloidyTemplate(example.exp, sample.label.all = "cellline3", ploidy.all = 2)
example.exp <- getPloidy(example.exp, control.ploidy = control.ploidy, sample.category = "cluster")
example.exp <- smoothPloidy(example.exp)
```

Visualize ploidy. Visualization reveals that cell line 1 has 1 copy of chromosome arm 1p, and cell line 2 has three copies of chromosome 7.

```{r}
assayHeatmap(example.exp, assay = "ploidy", split.col.by = "arm", split.row.by = "cluster", annotate.row.by = "cluster", color.preset = "ploidy")
assayHeatmap(example.exp, alt.exp = "smoothedPloidyByArm", assay = "discretePloidy", split.row.by = "cluster", annotate.row.by = "cluster", color.preset = "ploidy")
```

Visualize chrY counts. Visualization reveals that celline 2 has chr Y and is therefore male, while the other two cell lines are female. 

```{r}
assayBoxPlot(example.exp, alt.exp = "chrYCounts", split.features = T, split.x.by = "cluster")
```