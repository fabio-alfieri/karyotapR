---
title: "karyotapR Basic Workflow"
date: 'Compiled on `r format(Sys.Date(), "%B %d, %Y")`'
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Setup

```{r setup, message=FALSE}
library(karyotapR)
library(forcats)
set.seed(2023) #seed is set to ensure tutorial is reproducible 
```

## Data Download

This guide uses the cell mixture experiment from the KaryoTap publication ([Mays, 2023](https://www.biorxiv.org/content/10.1101/2023.09.08.555746v1)). The Tapestri Pipeline `.h5` output file is available on [Zenodo](https://doi.org/10.5281/zenodo.8305841) and can be downloaded by [`curl::curl_download()`] or directly from the website.

```{r, eval = FALSE}
curl::curl_download(url = "https://zenodo.org/record/8305841/files/tapestri-experiment01-panelv1.h5?download=1", 
                    destfile = "./tap-cellmixture.h5", 
                    quiet = FALSE)
```
# Basic Usage

## Data Import

The cell mixture dataset is imported from the `.h5` file that is generated by the Tapestri Pipeline, which generates a new `TapestriExpriment` object. This dataset comprises a mixture of 5 cell lines with differing karyotypes and was processed on the Tapestri instrument for single-cell DNA sequencing using Custom Oligo Panel 261 (a.k.a. Panel Version 1). Setting the `panel.id` parameter automatically assigns the correct probes to the `grnaProbe` and `barcodeProbe` slots in the object, which are used for special applications. Several useful processes run automatically on import, indicated in the status messages. For example, cytobands are automatically added to the probe metadata, chromosome Y probes are automatically detected and moved to a specific slot in the object (although now chrY probes exist in this panel), and any special probes that do target the endogenous human genome are moved to their appropriate slots.

```{r}
cellmix <- createTapestriExperiment("./tap-cellmixture.h5", panel.id = "CO261")
```

Calling the object will print a summary of the contained data. The `TapestriExperiment` class is built on top of the `SingleCellExperiment` and `SummarizedExperiment` classes, so they inherit their basic functionality and interface. Calling `colData()` and `rowData()` will return the metadata for the cells and probes/amplicons respectively. 

```{r}
cellmix
colData(cellmix) #cell metadata
rowData(cellmix) #probe metadata
```

## Allele Frequency Clustering

We cluster on allele frequency to partition different cell lines represented in the experiment.
First, we run Principal Components Analysis (PCA) and use the knee plot to identify the principal components (PCs) accounting for the most variation in the dataset.

```{r pca}
cellmix <- runPCA(cellmix)
PCAKneePlot(cellmix)
```

Next, we run UMAP with the top PCs to embed them into two dimensions and plot the result.

```{r umap1}
cellmix <- runUMAP(cellmix, pca.dims = 1:4)
reducedDimPlot(cellmix, dim.reduction = "umap")
```

Next, we partition the data into clusters using the dbscan method. The `eps` parameter can be used to adjust the granularity of the clustering. We can then update the UMAP plot with the clusters.

```{r clustering}
cellmix <- runClustering(cellmix, eps = 0.9)
reducedDimPlot(cellmix, dim.reduction = "umap", group.label = "cluster")
```

As expected, we have 5 major clusters corresponding to the 5 cell lines in the sequencing run, with the smaller clusters representing doublets (i.e., two cells in sequenced together in one droplet). We can subset the doublets out by pulling the cell barcodes corresponding to clusters 1-5 (clusters are ordered and named by descending size) and using those to subset the "columns" of the object into a new object. This is done here using a logical vector, but the cell barcodes can be passed in as a character vector of barcodes as well.

```{r}
cellmix.subset <- cellmix[,colData(cellmix)$cluster %in% 1:5]
```

We'll rename the cluster labels by renaming the factor levels of the "cluster" column in the `colData` slot, print an updated plot, and count the number of cells in each cluster.

```{r}
colData(cellmix.subset)$cluster <- forcats::fct_recode(colData(cellmix.subset)$cluster, cellline1 = "1", cellline2 = "2", cellline3 = "3", cellline4 = "4", cellline5 = "5")
reducedDimPlot(cellmix.subset, dim.reduction = "umap", group.label = "cluster")
forcats::fct_count(colData(cellmix.subset)$cluster)
```

## Copy Number Calling 

The KaryoTap method works best with a reference population where the copy number for each chromosome arm is known. Here we used RPE1 cells which are diploid (2 copies) except for a third copy of the chromosome 10q arm. We know from the KaryoTap preprint that "cellline2" corresponds to the RPE1 cells.

Her we normalize the read counts in the object and calculate a copy number score relative to cellline 2. `control.copy.number` gives the cluster label and copy number value to normalize each chromosome arm to. [`generateControlCopyNumberTemplate()`] creates a dataframe that is used to indicate the copy number of the reference population. The entry for chr10q has to be changed to 3. 

```{r copy number calc}
cellmix.subset <- calcNormCounts(cellmix.subset)
control.copy.number <- generateControlCopyNumberTemplate(cellmix.subset, sample.feature.label = "cellline3", copy.number = 2)
control.copy.number["10q", "copy.number"] <- 3
cellmix.subset <- calcCopyNumber(cellmix.subset, control.copy.number = control.copy.number, sample.feature = "cluster")
cellmix.subset <- calcSmoothCopyNumber(cellmix.subset)
```

Visualize copy number. Visualization reveals that cell line 1 has 1 copy of chromosome arm 1p, and cell line 2 has three copies of chromosome 7.

```{r heatmaps1}
assayHeatmap(cellmix.subset, assay = "copyNumber", split.col.by = "arm", split.row.by = "cluster", annotate.row.by = "cluster", color.preset = "copy.number")
assayHeatmap(cellmix.subset, alt.exp = "smoothedCopyNumberByArm", assay = "discreteCopyNumber", split.row.by = "cluster", annotate.row.by = "cluster", color.preset = "copy.number")
```

Visualize chrY counts. Visualization reveals that cellline 2 has chr Y and is therefore male, while the other two cell lines are female. 

```{r boxplot, dpi=300, eval = F}
assayBoxPlot(cellmix, alt.exp = "chrYCounts", split.features = TRUE, split.x.by = "cluster")
```


# Session Info

```{r}
sessioninfo::session_info()
```

